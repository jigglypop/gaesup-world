import{m as yt,_ as gt}from"./three-drei-enWTNQzH.js";import{ActiveEvents as ve,RigidBodyDesc as vt,ColliderDesc as Ct,Vector3 as Ne,EventQueue as bt}from"./physics-engine-CmnDU9Yz.js";import{R as c,r as l,s as Et,u as ht,a as Xe}from"./three-fiber-BZljtFsf.js";import{G as xt,aZ as St,d as V,q as be,a_ as Ee,p as Pt,ah as Rt,h as Ue}from"./three-core-Bc71Y2F5.js";function wt(e,t){if(typeof e!="object"||!e)return e;var o=e[Symbol.toPrimitive];if(o!==void 0){var n=o.call(e,t);if(typeof n!="object")return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return(t==="string"?String:Number)(e)}function Ft(e){var t=wt(e,"string");return typeof t=="symbol"?t:t+""}function Mt(e,t,o){return(t=Ft(t))in e?Object.defineProperty(e,t,{value:o,enumerable:!0,configurable:!0,writable:!0}):e[t]=o,e}function Qe(e,t){var o=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter(function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable})),o.push.apply(o,n)}return o}function m(e){for(var t=1;t<arguments.length;t++){var o=arguments[t]!=null?arguments[t]:{};t%2?Qe(Object(o),!0).forEach(function(n){Mt(e,n,o[n])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(o)):Qe(Object(o)).forEach(function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(o,n))})}return e}const jt=new be;new Ee;const Ot=new V;new xt;const Q=new Pt,M=new V,k=new be,X=new V,At=e=>{const[t,o,n]=e;return new V(t,o,n)},Ke=({x:e,y:t,z:o,w:n})=>jt.set(e,t,o,n),Bt=e=>{if(Array.isArray(e))return new Ne(e[0],e[1],e[2]);if(typeof e=="number")return new Ne(e,e,e);{const t=e;return new Ne(t.x,t.y,t.z)}},It={fixed:1,dynamic:0,kinematicPosition:2,kinematicVelocity:3},Je=e=>It[e],Dt=(e,t)=>{const o=Array.from(e);for(let n=0;n<e.length/3;n++)o[n*3]*=t.x,o[n*3+1]*=t.y,o[n*3+2]*=t.z;return o},_e=e=>e?e instanceof be?[e.x,e.y,e.z,e.w]:e instanceof V||e instanceof Ee?[e.x,e.y,e.z]:Array.isArray(e)?e:[e]:[0];function U(e){const t=l.useRef();return t.current===void 0&&(t.current={value:typeof e=="function"?e():e}),t.current.value}const Tt=e=>{const t=l.useRef(e),o=l.useRef(0),n=l.useRef(0);l.useEffect(()=>{t.current=e},[e]),l.useEffect(()=>{const r=()=>{const i=performance.now(),a=i-n.current;o.current=requestAnimationFrame(r),t.current(a/1e3),n.current=i};return o.current=requestAnimationFrame(r),()=>cancelAnimationFrame(o.current)},[])},Wt=({onStep:e,updatePriority:t})=>(Xe((o,n)=>{e(n)},t),null),zt=({onStep:e})=>(Tt(t=>{e(t)}),null),Nt=({onStep:e,type:t,updatePriority:o})=>t==="independent"?c.createElement(zt,{onStep:e}):c.createElement(Wt,{onStep:e,updatePriority:o});var qt=l.memo(Nt);function Vt(e,t){if(e==null)return{};var o={};for(var n in e)if({}.hasOwnProperty.call(e,n)){if(t.includes(n))continue;o[n]=e[n]}return o}function qe(e,t){if(e==null)return{};var o,n,r=Vt(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)o=i[n],t.includes(o)||{}.propertyIsEnumerable.call(e,o)&&(r[o]=e[o])}return r}const kt=["mass","linearDamping","angularDamping","type","onCollisionEnter","onCollisionExit","onIntersectionEnter","onIntersectionExit","onContactForce","children","canSleep","ccd","gravityScale","softCcdPrediction"],Lt=(e,t,o)=>{const n=t.slice();if(e==="heightfield"){const i=n[3];return i.x*=o.x,i.x*=o.y,i.x*=o.z,n}if(e==="trimesh"||e==="convexHull")return n[0]=Dt(n[0],o),n;const r=[o.x,o.y,o.z,o.x,o.x];return n.map((i,a)=>r[a]*i)},Gt=(e,t,o,n)=>{const r=Lt(e.shape,e.args,o),i=Ct[e.shape](...r);return t.createCollider(i,n==null?void 0:n())},Ht=["shape","args"],Ye="Please pick ONLY ONE of the `density`, `mass` and `massProperties` options.",Ut=(e,t)=>{if(t.density!==void 0){if(t.mass!==void 0||t.massProperties!==void 0)throw new Error(Ye);e.setDensity(t.density);return}if(t.mass!==void 0){if(t.massProperties!==void 0)throw new Error(Ye);e.setMass(t.mass);return}t.massProperties!==void 0&&e.setMassProperties(t.massProperties.mass,t.massProperties.centerOfMass,t.massProperties.principalAngularInertia,t.massProperties.angularInertiaLocalFrame)},$e={sensor:(e,t)=>{e.setSensor(t)},collisionGroups:(e,t)=>{e.setCollisionGroups(t)},solverGroups:(e,t)=>{e.setSolverGroups(t)},friction:(e,t)=>{e.setFriction(t)},frictionCombineRule:(e,t)=>{e.setFrictionCombineRule(t)},restitution:(e,t)=>{e.setRestitution(t)},restitutionCombineRule:(e,t)=>{e.setRestitutionCombineRule(t)},activeCollisionTypes:(e,t)=>{e.setActiveCollisionTypes(t)},contactSkin:(e,t)=>{e.setContactSkin(t)},quaternion:()=>{},position:()=>{},rotation:()=>{},scale:()=>{}},et=Object.keys($e),Qt=(e,t,o)=>{const n=o.get(e.handle);if(n){var r;const i=n.object.parent.getWorldScale(Ot),a=(r=n.worldParent)===null||r===void 0?void 0:r.matrixWorld.clone().invert();n.object.updateWorldMatrix(!0,!1),Q.copy(n.object.matrixWorld),a&&Q.premultiply(a),Q.decompose(M,k,X),e.parent()?(e.setTranslationWrtParent({x:M.x*i.x,y:M.y*i.y,z:M.z*i.z}),e.setRotationWrtParent(k)):(e.setTranslation({x:M.x*i.x,y:M.y*i.y,z:M.z*i.z}),e.setRotation(k)),et.forEach(d=>{if(d in t){const g=t[d];$e[d](e,g,t)}}),Ut(e,t)}},Kt=(e,t,o)=>{const n=l.useMemo(()=>et.flatMap(r=>_e(t[r])),[t]);l.useEffect(()=>{const r=e();Qt(r,t,o)},[...n,e])},Yt=e=>{let t=!1;return e.traverseAncestors(o=>{o.userData.r3RapierType==="MeshCollider"&&(t=!0)}),t},Zt=(e,t,o)=>({collider:e,worldParent:o||void 0,object:t}),Xt={cuboid:"cuboid",ball:"ball",hull:"convexHull",trimesh:"trimesh"},Jt=({object:e,ignoreMeshColliders:t=!0,options:o})=>{const n=[];e.updateWorldMatrix(!0,!1);const r=e.matrixWorld.clone().invert(),i=a=>{if("isMesh"in a){if(t&&Yt(a))return;const d=a.getWorldScale(X),g=Xt[o.colliders||"cuboid"];a.updateWorldMatrix(!0,!1),Q.copy(a.matrixWorld).premultiply(r).decompose(M,k,X);const p=new Ee().setFromQuaternion(k,"XYZ"),{geometry:E}=a,{args:f,offset:h}=_t(E,o.colliders||"cuboid"),R=m(m({},nt(o)),{},{args:f,shape:g,rotation:[p.x,p.y,p.z],position:[M.x+h.x*d.x,M.y+h.y*d.y,M.z+h.z*d.z],scale:[d.x,d.y,d.z]});n.push(R)}};return o.includeInvisible?e.traverse(i):e.traverseVisible(i),n},_t=(e,t)=>{switch(t){case"cuboid":{e.computeBoundingBox();const{boundingBox:n}=e,r=n.getSize(new V);return{args:[r.x/2,r.y/2,r.z/2],offset:n.getCenter(new V)}}case"ball":{e.computeBoundingSphere();const{boundingSphere:n}=e;return{args:[n.radius],offset:n.center}}case"trimesh":{var o;const n=e.index?e.clone():yt(e);return{args:[n.attributes.position.array,(o=n.index)===null||o===void 0?void 0:o.array],offset:new V}}case"hull":return{args:[e.clone().attributes.position.array],offset:new V}}return{args:[],offset:new V}},tt=e=>({collision:!!(e!=null&&e.onCollisionEnter||e!=null&&e.onCollisionExit||e!=null&&e.onIntersectionEnter||e!=null&&e.onIntersectionExit),contactForce:!!(e!=null&&e.onContactForce)}),$t=(e,t,o,n={})=>{const{onCollisionEnter:r,onCollisionExit:i,onIntersectionEnter:a,onIntersectionExit:d,onContactForce:g}=t;l.useEffect(()=>{const p=e();if(p){const{collision:E,contactForce:f}=tt(t),h=E||n.collision,R=f||n.contactForce;h&&R?p.setActiveEvents(ve.COLLISION_EVENTS|ve.CONTACT_FORCE_EVENTS):h?p.setActiveEvents(ve.COLLISION_EVENTS):R&&p.setActiveEvents(ve.CONTACT_FORCE_EVENTS),o.set(p.handle,{onCollisionEnter:r,onCollisionExit:i,onIntersectionEnter:a,onIntersectionExit:d,onContactForce:g})}return()=>{p&&o.delete(p.handle)}},[r,i,a,d,g,n])},nt=(e={})=>qe(e,kt),he=()=>{const e=l.useContext(ot);if(!e)throw new Error("react-three-rapier: useRapier must be used within <Physics />!");return e},Ve=(e,t,o=!0)=>{const[n,r]=l.useState([]);return l.useEffect(()=>{e.current&&t.colliders!==!1&&r(Jt({object:e.current,options:t,ignoreMeshColliders:o}))},[t.colliders]),n},en=l.memo(()=>{const{world:e}=he(),t=l.useRef(null);return Xe(()=>{const o=t.current;if(!o)return;const n=e.debugRender();o.geometry.setAttribute("position",new Ue(n.vertices,3)),o.geometry.setAttribute("color",new Ue(n.colors,4))}),c.createElement("group",null,c.createElement("lineSegments",{ref:t,frustumCulled:!1},c.createElement("lineBasicMaterial",{color:16777215,vertexColors:!0}),c.createElement("bufferGeometry",null)))}),tn=e=>{let t;const o={get(a,d){return t||(t=e()),Reflect.get(t,d)},set(a,d,g){return t||(t=e()),Reflect.set(t,d,g)}};return{proxy:new Proxy({},o),reset:()=>{t=void 0},set:a=>{t=a}}},ot=l.createContext(void 0),Ce=(e,t)=>{var o,n,r,i,a,d;return{target:{rigidBody:e.rigidBody.object,collider:e.collider.object,colliderObject:(o=e.collider.state)===null||o===void 0?void 0:o.object,rigidBodyObject:(n=e.rigidBody.state)===null||n===void 0?void 0:n.object},other:{rigidBody:t.rigidBody.object,collider:t.collider.object,colliderObject:(r=t.collider.state)===null||r===void 0?void 0:r.object,rigidBodyObject:(i=t.rigidBody.state)===null||i===void 0?void 0:i.object},rigidBody:t.rigidBody.object,collider:t.collider.object,colliderObject:(a=t.collider.state)===null||a===void 0?void 0:a.object,rigidBodyObject:(d=t.rigidBody.state)===null||d===void 0?void 0:d.object}},Ze=async()=>{let e=await gt(()=>import("./physics-engine-CmnDU9Yz.js"),[],import.meta.url);return await e.init(),e},Fn=e=>{const{colliders:t="cuboid",children:o,timeStep:n=1/60,paused:r=!1,interpolate:i=!0,updatePriority:a,updateLoop:d="follow",debug:g=!1,gravity:p=[0,-9.81,0],allowedLinearError:E=.001,predictionDistance:f=.002,numSolverIterations:h=4,numAdditionalFrictionIterations:R=4,numInternalPgsIterations:L=1,minIslandSize:T=128,maxCcdSubsteps:y=1,contactNaturalFrequency:v=30,lengthUnit:b=1}=e,x=Et(Ze,["@react-thee/rapier",Ze]),{invalidate:xe}=ht(),S=U(()=>new Map),W=U(()=>new Map),Se=U(()=>new Map),Le=U(()=>new Map),Pe=U(()=>new bt(!1)),Ge=U(()=>new Set),He=U(()=>new Set),{proxy:w,reset:ut,set:ft}=U(()=>tn(()=>new x.World(At(p))));l.useEffect(()=>()=>{w.free(),ut()},[]),l.useEffect(()=>{w.gravity=Bt(p),w.integrationParameters.numSolverIterations=h,w.integrationParameters.numAdditionalFrictionIterations=R,w.integrationParameters.numInternalPgsIterations=L,w.integrationParameters.normalizedAllowedLinearError=E,w.integrationParameters.minIslandSize=T,w.integrationParameters.maxCcdSubsteps=y,w.integrationParameters.normalizedPredictionDistance=f,w.lengthUnit=b,w.integrationParameters.contact_natural_frequency=v},[w,...p,h,R,L,E,T,y,f,b,v]);const _=l.useCallback(G=>{var B;const Y=w.getCollider(G),ee=Le.get(G),te=W.get(G),H=Y==null||(B=Y.parent())===null||B===void 0?void 0:B.handle,s=H!==void 0?w.getRigidBody(H):void 0,j=s&&H!==void 0?Se.get(H):void 0,O=H!==void 0?S.get(H):void 0;return{collider:{object:Y,events:ee,state:te},rigidBody:{object:s,events:j,state:O}}},[]),[K]=l.useState({previousState:{},accumulator:0}),$=l.useCallback(G=>{const B=w,Y=n==="vary",ee=Rt.clamp(G,0,.5),te=s=>{Ge.forEach(j=>{j.current(B)}),B.timestep=s,B.step(Pe),He.forEach(j=>{j.current(B)})};if(Y)te(ee);else for(K.accumulator+=ee;K.accumulator>=n;)i&&(K.previousState={},B.forEachRigidBody(s=>{K.previousState[s.handle]={position:s.translation(),rotation:s.rotation()}})),te(n),K.accumulator-=n;const H=Y||!i||r?1:K.accumulator/n;S.forEach((s,j)=>{const O=B.getRigidBody(j),u=Se.get(j);if(u!=null&&u.onSleep||u!=null&&u.onWake){if(O.isSleeping()&&!s.isSleeping){var C;u==null||(C=u.onSleep)===null||C===void 0||C.call(u)}if(!O.isSleeping()&&s.isSleeping){var F;u==null||(F=u.onWake)===null||F===void 0||F.call(u)}s.isSleeping=O.isSleeping()}if(!O||O.isSleeping()&&!("isInstancedMesh"in s.object)||!s.setMatrix)return;let A=O.translation(),z=O.rotation(),N=K.previousState[j];N&&(Q.compose(N.position,Ke(N.rotation),s.scale).premultiply(s.invertedWorldMatrix).decompose(M,k,X),s.meshType=="mesh"&&(s.object.position.copy(M),s.object.quaternion.copy(k))),Q.compose(A,Ke(z),s.scale).premultiply(s.invertedWorldMatrix).decompose(M,k,X),s.meshType=="instancedMesh"?s.setMatrix(Q):(s.object.position.lerp(M,H),s.object.quaternion.slerp(k,H))}),Pe.drainCollisionEvents((s,j,O)=>{const u=_(s),C=_(j);if(!(u!=null&&u.collider.object)||!(C!=null&&C.collider.object))return;const F=Ce(u,C),A=Ce(C,u);if(O)B.contactPair(u.collider.object,C.collider.object,(ue,fe)=>{var me,De,pe,Te,ye,We,ge,ze;(me=u.rigidBody.events)===null||me===void 0||(De=me.onCollisionEnter)===null||De===void 0||De.call(me,m(m({},F),{},{manifold:ue,flipped:fe})),(pe=C.rigidBody.events)===null||pe===void 0||(Te=pe.onCollisionEnter)===null||Te===void 0||Te.call(pe,m(m({},A),{},{manifold:ue,flipped:fe})),(ye=u.collider.events)===null||ye===void 0||(We=ye.onCollisionEnter)===null||We===void 0||We.call(ye,m(m({},F),{},{manifold:ue,flipped:fe})),(ge=C.collider.events)===null||ge===void 0||(ze=ge.onCollisionEnter)===null||ze===void 0||ze.call(ge,m(m({},A),{},{manifold:ue,flipped:fe}))});else{var z,N,D,q,Z,J,ne,Re;(z=u.rigidBody.events)===null||z===void 0||(N=z.onCollisionExit)===null||N===void 0||N.call(z,F),(D=C.rigidBody.events)===null||D===void 0||(q=D.onCollisionExit)===null||q===void 0||q.call(D,A),(Z=u.collider.events)===null||Z===void 0||(J=Z.onCollisionExit)===null||J===void 0||J.call(Z,F),(ne=C.collider.events)===null||ne===void 0||(Re=ne.onCollisionExit)===null||Re===void 0||Re.call(ne,A)}if(O){if(B.intersectionPair(u.collider.object,C.collider.object)){var oe,we,re,Fe,ie,Me,le,je;(oe=u.rigidBody.events)===null||oe===void 0||(we=oe.onIntersectionEnter)===null||we===void 0||we.call(oe,F),(re=C.rigidBody.events)===null||re===void 0||(Fe=re.onIntersectionEnter)===null||Fe===void 0||Fe.call(re,A),(ie=u.collider.events)===null||ie===void 0||(Me=ie.onIntersectionEnter)===null||Me===void 0||Me.call(ie,F),(le=C.collider.events)===null||le===void 0||(je=le.onIntersectionEnter)===null||je===void 0||je.call(le,A)}}else{var se,Oe,ae,Ae,ce,Be,de,Ie;(se=u.rigidBody.events)===null||se===void 0||(Oe=se.onIntersectionExit)===null||Oe===void 0||Oe.call(se,F),(ae=C.rigidBody.events)===null||ae===void 0||(Ae=ae.onIntersectionExit)===null||Ae===void 0||Ae.call(ae,A),(ce=u.collider.events)===null||ce===void 0||(Be=ce.onIntersectionExit)===null||Be===void 0||Be.call(ce,F),(de=C.collider.events)===null||de===void 0||(Ie=de.onIntersectionExit)===null||Ie===void 0||Ie.call(de,A)}}),Pe.drainContactForceEvents(s=>{var j,O,u,C,F,A,z,N;const D=_(s.collider1()),q=_(s.collider2());if(!(D!=null&&D.collider.object)||!(q!=null&&q.collider.object))return;const Z=Ce(D,q),J=Ce(q,D);(j=D.rigidBody.events)===null||j===void 0||(O=j.onContactForce)===null||O===void 0||O.call(j,m(m({},Z),{},{totalForce:s.totalForce(),totalForceMagnitude:s.totalForceMagnitude(),maxForceDirection:s.maxForceDirection(),maxForceMagnitude:s.maxForceMagnitude()})),(u=q.rigidBody.events)===null||u===void 0||(C=u.onContactForce)===null||C===void 0||C.call(u,m(m({},J),{},{totalForce:s.totalForce(),totalForceMagnitude:s.totalForceMagnitude(),maxForceDirection:s.maxForceDirection(),maxForceMagnitude:s.maxForceMagnitude()})),(F=D.collider.events)===null||F===void 0||(A=F.onContactForce)===null||A===void 0||A.call(F,m(m({},Z),{},{totalForce:s.totalForce(),totalForceMagnitude:s.totalForceMagnitude(),maxForceDirection:s.maxForceDirection(),maxForceMagnitude:s.maxForceMagnitude()})),(z=q.collider.events)===null||z===void 0||(N=z.onContactForce)===null||N===void 0||N.call(z,m(m({},J),{},{totalForce:s.totalForce(),totalForceMagnitude:s.totalForceMagnitude(),maxForceDirection:s.maxForceDirection(),maxForceMagnitude:s.maxForceMagnitude()}))}),B.forEachActiveRigidBody(()=>{xe()})},[r,n,i,w]),mt=l.useMemo(()=>({rapier:x,world:w,setWorld:G=>{ft(G)},physicsOptions:{colliders:t,gravity:p},rigidBodyStates:S,colliderStates:W,rigidBodyEvents:Se,colliderEvents:Le,beforeStepCallbacks:Ge,afterStepCallbacks:He,isPaused:r,isDebug:g,step:$}),[r,$,g,t,p]),pt=l.useCallback(G=>{r||$(G)},[r,$]);return c.createElement(ot.Provider,{value:mt},c.createElement(qt,{onStep:pt,type:d,updatePriority:a}),g&&c.createElement(en,null),o)};function P(){return P=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var o=arguments[t];for(var n in o)({}).hasOwnProperty.call(o,n)&&(e[n]=o[n])}return e},P.apply(null,arguments)}const rt=(e,t,o)=>{const n=l.useRef(),r=l.useCallback(()=>(n.current||(n.current=e()),n.current),o);return l.useEffect(()=>{const i=r(),a=()=>t(i);return()=>{a(),n.current=void 0}},[r]),r},nn=({x:e,y:t,z:o}={x:0,y:0,z:0})=>new V(e,t,o),Mn=({x:e,y:t,z:o,w:n}={x:0,y:0,z:0,w:1})=>new be(e,t,o,n),jn=({x:e,y:t,z:o}={x:0,y:0,z:0})=>new Ee(e,t,o),ke=(e,t=null)=>{const o=l.useRef(t);return e&&typeof e!="function"?(e.current||(e.current=o.current),e):o},I=l.memo(l.forwardRef((e,t)=>{const{children:o,position:n,rotation:r,quaternion:i,scale:a,name:d}=e,{world:g,colliderEvents:p,colliderStates:E}=he(),f=ct(),h=ke(t),R=l.useRef(null),L=Ht.flatMap(v=>Array.isArray(e[v])?[...e[v]]:e[v]),T=rt(()=>{const v=R.current.getWorldScale(nn()),b=Gt(e,g,v,f==null?void 0:f.getRigidBody);return typeof t=="function"&&t(b),h.current=b,b},v=>{g.getCollider(v.handle)&&g.removeCollider(v,!0)},[...L,f]);l.useEffect(()=>{const v=T();return E.set(v.handle,Zt(v,R.current,f==null?void 0:f.ref.current)),()=>{E.delete(v.handle)}},[T]);const y=l.useMemo(()=>m(m({},nt(f==null?void 0:f.options)),e),[e,f==null?void 0:f.options]);return Kt(T,y,E),$t(T,y,p,tt(f==null?void 0:f.options)),c.createElement("object3D",{position:n,rotation:r,quaternion:i,scale:a,ref:R,name:d},o)})),on=c.forwardRef((e,t)=>c.createElement(I,P({},e,{shape:"cuboid",ref:t})));on.displayName="CuboidCollider";const rn=c.forwardRef((e,t)=>c.createElement(I,P({},e,{shape:"roundCuboid",ref:t})));rn.displayName="RoundCuboidCollider";const ln=c.forwardRef((e,t)=>c.createElement(I,P({},e,{shape:"ball",ref:t})));ln.displayName="BallCollider";const sn=c.forwardRef((e,t)=>c.createElement(I,P({},e,{shape:"capsule",ref:t})));sn.displayName="CapsuleCollider";const an=c.forwardRef((e,t)=>c.createElement(I,P({},e,{shape:"heightfield",ref:t})));an.displayName="HeightfieldCollider";const cn=c.forwardRef((e,t)=>c.createElement(I,P({},e,{shape:"trimesh",ref:t})));cn.displayName="TrimeshCollider";const dn=c.forwardRef((e,t)=>c.createElement(I,P({},e,{shape:"cone",ref:t})));dn.displayName="ConeCollider";const un=c.forwardRef((e,t)=>c.createElement(I,P({},e,{shape:"roundCone",ref:t})));un.displayName="RoundConeCollider";const it=c.forwardRef((e,t)=>c.createElement(I,P({},e,{shape:"cylinder",ref:t})));it.displayName="CylinderCollider";it.displayName="RoundCylinderCollider";const fn=c.forwardRef((e,t)=>c.createElement(I,P({},e,{shape:"convexHull",ref:t})));fn.displayName="ConvexHullCollider";const mn=e=>{var t;const o=Je((e==null?void 0:e.type)||"dynamic"),n=new vt(o);return n.canSleep=(t=e==null?void 0:e.canSleep)!==null&&t!==void 0?t:!0,n},pn=({rigidBody:e,object:t,setMatrix:o,getMatrix:n,worldScale:r,meshType:i="mesh"})=>{t.updateWorldMatrix(!0,!1);const a=t.parent.matrixWorld.clone().invert();return{object:t,rigidBody:e,invertedWorldMatrix:a,setMatrix:o||(d=>{t.matrix.copy(d)}),getMatrix:n||(d=>d.copy(t.matrix)),scale:r||t.getWorldScale(X).clone(),isSleeping:!1,meshType:i}},yn=["args","colliders","canSleep"],lt={gravityScale:(e,t)=>{e.setGravityScale(t,!0)},additionalSolverIterations(e,t){e.setAdditionalSolverIterations(t)},linearDamping:(e,t)=>{e.setLinearDamping(t)},angularDamping:(e,t)=>{e.setAngularDamping(t)},dominanceGroup:(e,t)=>{e.setDominanceGroup(t)},enabledRotations:(e,[t,o,n])=>{e.setEnabledRotations(t,o,n,!0)},enabledTranslations:(e,[t,o,n])=>{e.setEnabledTranslations(t,o,n,!0)},lockRotations:(e,t)=>{e.lockRotations(t,!0)},lockTranslations:(e,t)=>{e.lockTranslations(t,!0)},angularVelocity:(e,[t,o,n])=>{e.setAngvel({x:t,y:o,z:n},!0)},linearVelocity:(e,[t,o,n])=>{e.setLinvel({x:t,y:o,z:n},!0)},ccd:(e,t)=>{e.enableCcd(t)},softCcdPrediction:(e,t)=>{e.setSoftCcdPrediction(t)},userData:(e,t)=>{e.userData=t},type(e,t){e.setBodyType(Je(t),!0)},position:()=>{},rotation:()=>{},quaternion:()=>{},scale:()=>{}},st=Object.keys(lt),gn=(e,t,o,n=!0)=>{if(!e)return;const r=o.get(e.handle);r&&(n&&(r.object.updateWorldMatrix(!0,!1),Q.copy(r.object.matrixWorld).decompose(M,k,X),e.setTranslation(M,!1),e.setRotation(k,!1)),st.forEach(i=>{i in t&&lt[i](e,t[i])}))},vn=(e,t,o,n=!0)=>{const r=l.useMemo(()=>st.flatMap(i=>_e(t[i])),[t]);l.useEffect(()=>{const i=e();gn(i,t,o,n)},r)},Cn=(e,t,o)=>{const{onWake:n,onSleep:r,onCollisionEnter:i,onCollisionExit:a,onIntersectionEnter:d,onIntersectionExit:g,onContactForce:p}=t,E={onWake:n,onSleep:r,onCollisionEnter:i,onCollisionExit:a,onIntersectionEnter:d,onIntersectionExit:g,onContactForce:p};l.useEffect(()=>{const f=e();return o.set(f.handle,E),()=>{o.delete(f.handle)}},[n,r,i,a,d,g,p])},bn=["children","type","position","rotation","scale","quaternion","transformState"],at=l.createContext(void 0),ct=()=>l.useContext(at),dt=l.memo(l.forwardRef((e,t)=>{const{children:o,type:n,position:r,rotation:i,scale:a,quaternion:d,transformState:g}=e,p=qe(e,bn),E=l.useRef(null),f=ke(t),{world:h,rigidBodyStates:R,physicsOptions:L,rigidBodyEvents:T}=he(),y=l.useMemo(()=>m(m(m({},L),e),{},{children:void 0}),[L,e]),v=yn.flatMap(S=>Array.isArray(y[S])?[...y[S]]:y[S]),b=Ve(E,y),x=rt(()=>{const S=mn(y),W=h.createRigidBody(S);return typeof t=="function"&&t(W),f.current=W,W},S=>{h.getRigidBody(S.handle)&&h.removeRigidBody(S)},v);l.useEffect(()=>{const S=x(),W=pn({rigidBody:S,object:E.current});return R.set(S.handle,e.transformState?e.transformState(W):W),()=>{R.delete(S.handle)}},[x]),vn(x,y,R),Cn(x,y,T);const xe=l.useMemo(()=>({ref:E,getRigidBody:x,options:y}),[x]);return c.createElement(at.Provider,{value:xe},c.createElement("object3D",P({ref:E},p,{position:r,rotation:i,quaternion:d,scale:a}),o,b.map((S,W)=>c.createElement(I,P({key:W},S)))))}));dt.displayName="RigidBody";const En=l.memo(e=>{const{children:t,type:o}=e,{physicsOptions:n}=he(),r=l.useRef(null),{options:i}=ct(),a=l.useMemo(()=>m(m(m({},n),i),{},{children:void 0,colliders:o}),[n,i]),d=Ve(r,a,!1);return c.createElement("object3D",{ref:r,userData:{r3RapierType:"MeshCollider"}},t,d.map((g,p)=>c.createElement(I,P({key:p},g))))});En.displayName="MeshCollider";const hn=["children","instances","colliderNodes","position","rotation","quaternion","scale"],xn=l.memo(l.forwardRef((e,t)=>{const o=ke(t,[]),n=l.useRef(null),r=l.useRef(null),{children:i,instances:a,colliderNodes:d=[],position:g,rotation:p,quaternion:E,scale:f}=e,h=qe(e,hn),R=Ve(n,m(m({},e),{},{children:void 0})),L=()=>{const y=r.current.children[0];if(y&&"isInstancedMesh"in y)return y};l.useEffect(()=>{const y=L();y?y.instanceMatrix.setUsage(St):console.warn("InstancedRigidBodies expects exactly one child, which must be an InstancedMesh")},[]);const T=(y,v)=>{const b=L();return b?m(m({},y),{},{getMatrix:x=>(b.getMatrixAt(v,x),x),setMatrix:x=>{b.setMatrixAt(v,x),b.instanceMatrix.needsUpdate=!0},meshType:"instancedMesh"}):y};return c.createElement("object3D",P({ref:n},h,{position:g,rotation:p,quaternion:E,scale:f}),c.createElement("object3D",{ref:r},i),a==null?void 0:a.map((y,v)=>c.createElement(dt,P({},h,y,{ref:b=>o.current[v]=b,transformState:b=>T(b,v)}),c.createElement(c.Fragment,null,d.map((b,x)=>c.createElement(l.Fragment,{key:x},b)),R.map((b,x)=>c.createElement(I,P({key:x},b)))))))}));xn.displayName="InstancedRigidBodies";export{sn as C,Fn as P,dt as R,jn as e,Mn as q,he as u,nn as v};
